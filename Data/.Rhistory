for(i in 1:length(professions.list)) {
GroupV = which(V(G_Grouped)$profession.df == professions.list[i])
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=1.5))
#print(paste0("Ran loop for profession ",professions.list[i]))
}
## Now create a layout based on G_Grouped
LO = layout_with_fr(G_Grouped)
LO<-norm_coords(LO, ymin=-1, ymax=1, xmin=-1, xmax=1)
plot(graph_complete_symmetrized,
layout=(LO*1.0),
rescale=F,
#edge.color=edge_test$connection,
edge.arrow.size=.5,
vertex.color=vertex_df$profession.df,
#vertex.size=((in.degree)*0.7),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.color= adjustcolor("black", 0.6),
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession)',
#frame=TRUE,
margin=0.0001)
#Add graph of strong/weak connections between professional groups
V(graph_complete_symmetrized)$profession.df
E(graph_complete_symmetrized)$profession.df
strength(graph_complete_symmetrized)
graph_attr(graph_complete_symmetrized)
E(graph_complete)[inc(V(graph_complete)[profession.df==professions.list[1]])]
g2 <- subgraph.edges(graph_complete, E(graph_complete)[inc(V(graph_complete)[profession.df==professions.list[1]])])
plot(g2,
layout=layout_in_circle,
rescale=T,
edge.color=adjustcolor("black", 0.1),
edge.arrow.size=0.1,
vertex.color=vertex_df$profession.df,
#vertex.size=((in.degree)*0.7),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.color= adjustcolor("black", 0.5),
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession)',
#frame=TRUE,
margin=0.0001)
plot.network.original <- plot(graph_complete_simpl,
layout = layout.fruchterman.reingold,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
#vertex.color=profession.colors,
#vertex.size=((in.degree)*1.5),
vertex.size=5,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="Network Plot (Generated Data)",
#frame=TRUE,
margin=0.0001)
plot(graph_complete_simpl,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
#vertex.color=profession.colors,
#vertex.size=((in.degree)*1.5),
vertex.size=5,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="Network Plot_Nicely",
#frame=TRUE,
margin=0.0001,
layout = layout_nicely)
plot(graph_complete_simpl,
layout = layout.graph,
rescale = F,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
vertex.color=profession.colors,
#vertex.size=((in.degree)*1.5),
vertex.size=5,
vertex.label=NA,
vertex.label.cex=0.5,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="SNA by Profession",
#frame=TRUE,
margin = 0.0001)
plot(graph_complete_symmetrized,
#edge.color=edge_test$connection,
edge.arrow.size=.5,
vertex.color=colrs[V(graph_complete_symmetrized)$community],
vertex.size=((in.degree)*1.5),
vertex.color=colrs,
#vertex.size=((in.degree)*1.5),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession/community)',
#frame=TRUE,
margin=0.0001)
plot(graph_complete.years,
layout=(layout.graph*1.1),
rescale=F,
#edge.color=edge_test$connection,
edge.arrow.size=.01,
vertex.color=vertex_df$profession,
#vertex.size=((in.degree)*0.9),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.6,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main=paste0('Network of worked-together-with ',cut.off,' years connection'),
#frame=TRUE,
margin=0.0001)
plot(graph_complete_symmetrized,
layout=(LO*1.0),
rescale=F,
#edge.color=edge_test$connection,
edge.arrow.size=.5,
vertex.color=vertex_df$profession.df,
#vertex.size=((in.degree)*0.7),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.color= adjustcolor("black", 0.6),
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession)',
#frame=TRUE,
margin=0.0001)
plot(g2,
layout=layout_in_circle,
rescale=T,
edge.color=adjustcolor("black", 0.1),
edge.arrow.size=0.1,
vertex.color=vertex_df$profession.df,
#vertex.size=((in.degree)*0.7),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.color= adjustcolor("black", 0.5),
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession)',
#frame=TRUE,
margin=0.0001)
degree_complete<-igraph::degree(graph_complete)
degree_max<-which.max(igraph::degree(graph_complete))
degree_min<-which.min(igraph::degree(graph_complete))
diameter_complete<-diameter(graph_complete)
closeness_complete<-igraph::closeness(graph_complete)
reciprocity_complete<-reciprocity(graph_complete)
ecount_complete<-ecount(graph_complete)
vcount_complete<-vcount(graph_complete)
density_complete<-edge_density(graph_complete)
########################################################
#Keyplayer functions:
#Convert igraph object into matrix object, which can be read by sna package
matrix_complete<-as.matrix(as_adjacency_matrix(graph_complete))
matrix_inv_non_zero <- matrix_complete
##### Plotting network with key player as identified by above model.
layout.graph <- layout_(graph_complete_simpl, nicely())
layout.graph<-norm_coords(layout.graph, ymin=-1, ymax=1, xmin=-1, xmax=1)
plot(graph_complete_simpl,
layout=layout.graph,
rescale=T,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
vertex.color=ifelse(vertex_df$ego == as.character(vertex_df$ego[177]), "Firebrick1", "Gray60"),
#vertex.size=((in.degree)*1.5),
#vertex.size=(igraph::degree(graph_complete)*0.5),
vertex.size=ifelse(vertex_df$ego == as.character(vertex_df$ego[177]), 8, 4),
vertex.label= ifelse(vertex_df$ego == as.character(vertex_df$ego[177]), as.character(vertex_df$ego), NA),
#label.color = "Firebrick1",
vertex.label=NA,
vertex.label.cex=ifelse(vertex_df$ego == as.character(vertex_df$ego[177]), .5, NA),
vertex.label.dist=0,
vertex.label.degree=0,
main='SNA with Key Player',
#frame=TRUE,
margin=0.0001)
#Display information as matrix format
#graph_complete[]
matrix_complete<-as.matrix(as_adjacency_matrix(graph_complete))
Keyplayer.list<-c(2,4,5,9,14,16,17,18,28,63,67)
data_logistic_df<-vertex_df
Keyplay.bool=ifelse(rownames(data_logistic_df) %in% Keyplayer.list,1,0)
data_logistic_df<-cbind(Keyplay.bool,data_logistic_df)
colnames(data_logistic_df)
data_logistic_df <- subset(data_logistic_df,
select=c(1,3,10,11,12,13,14,15))
model <- glm(Keyplay.bool ~.,family=binomial(link='logit'),data=data_logistic_df)
summary(model)
colnames(data_logistic_df)
data_logistic_df<-vertex_df
Keyplay.bool=ifelse(rownames(data_logistic_df) %in% Keyplayer.list,1,0)
data_logistic_df<-cbind(Keyplay.bool,data_logistic_df)
colnames(data_logistic_df)
data_logistic_df <- subset(data_logistic_df,
select=c(1,3,11,14))
model <- glm(Keyplay.bool ~.,family=binomial(link='logit'),data=data_logistic_df)
summary(model)
degree_complete
degree_max<-which.max(igraph::degree(graph_complete))
degree_min<-which.min(igraph::degree(graph_complete))
degree_max
degree_min
diameter_complete<-diameter(graph_complete)
diameter_complete
closeness_complete<-igraph::closeness(graph_complete)
closeness_complete
reciprocity_complete<-reciprocity(graph_complete)
reciprocity_complete
ecount_complete
vcount_complete
density_complete
diameter_complete
print0("The network has a diameter of ",diameter_complete)
print(paste0("The network has a diameter of ",diameter_complete))
diameter_complete
print(paste0("The network has a diameter of ",diameter_complete),". This measure is the length of the longest geodesic (the
largest distance between any two vertices in a connected graph).")
print(paste0("The network has a diameter of ",diameter_complete,". This measure is the length of the longest geodesic (the
)
)
print(paste0("The network has a diameter of ",diameter_complete,". This measure is the length of the longest geodesic (the
largest distance between any two vertices in a connected graph)."))
print(paste0("The network has a diameter of ",diameter_complete,". This measure is the length of the longest geodesic (the largest distance between any two vertices in a connected graph)."))
degree_max
degree_max[1]
degree_max[1,]
degree_max[,1]
degree_max[[1]]
degree_max[[2]]
degree_max[[1]]
print(paste0("The vertex with the greatest degree is ",degree_max,". This measure is the number of its adjacent edges."))
as.character(degree_max)
as.factor(degree_max)
as.factor(degree_max)[1]
str(degree_max)
degree_max$names
class(degree_max)
summary(graph_complete)
V(graph_complete)
V(graph_complete)[degree_max]
as.character(V(graph_complete)[degree_max])
V(graph_complete)[degree_max]
V(graph_complete)[degree_max][1]
V(graph_complete)[degree_max][1]
print(paste0("The vertex with the greatest degree is ",V(graph_complete)[degree_max][1],". This measure is the number of its adjacent edges."))
V(graph_complete)[degree_max][1]
V(graph_complete)[degree_max]$names
V(graph_complete)$names[degree_max]
V(graph_complete)
as.data.frame(V(graph_complete))[degree_max]
print(paste0("The vertex with the greatest degree is ",vertex_df$ego == as.character(vertex_df$ego[degree_max]," (number: ",degree_max,"). This measure is the number of its adjacent edges."))
print(paste0("The vertex with the greatest degree is ",as.character(vertex_df$ego[degree_max])," (number: ",degree_max,"). This measure is the number of its adjacent edges."))
#degree_complete<-igraph::degree(graph_complete)
degree_max<-which.max(igraph::degree(graph_complete))
print(paste0("The vertex with the greatest degree is ",as.character(vertex_df$ego[degree_max])," (number: ",degree_max,"). This measure is the number of its adjacent edges."))
degree_min<-which.min(igraph::degree(graph_complete))
print(paste0("The vertex with the fewest degree is ",as.character(vertex_df$ego[degree_min])," (number: ",degree_min,"). This measure is the number of its adjacent edges."))
closeness_complete<-igraph::closeness(graph_complete)
closeness_complete
closeness_max<-which.max(igraph::closeness_complete(graph_complete))
closeness_max<-which.max(igraph::closeness(graph_complete))
closeness_max
print(paste0("The vertex with the greatest degree is ",as.character(vertex_df$ego[degree_max])," (number: ",degree_max,"). This measure is the number of its adjacent edges."))
print(paste0("The vertex with the greatest closeness is ",as.character(vertex_df$ego[closeness_max])," (number: ",closeness_max,"). This measures how many steps is required to access every other vertex from a given
vertex."))
print(paste0("The network has a diameter of ",diameter_complete,". This measure is the length of the longest geodesic (the largest distance between any two vertices in a connected graph)."))
print(paste0("The vertex with the fewest degree is ",as.character(vertex_df$ego[degree_min])," (number: ",degree_min,"). This measure is the number of its adjacent edges."))
print(paste0("The vertex with the least closeness is ",as.character(vertex_df$ego[closeness_min])," (number: ",closeness_min,"). This measures how many steps is required to access every other vertex from a given
vertex."))
closeness_min<-which.min(igraph::closeness(graph_complete))
print(paste0("The vertex with the least closeness is ",as.character(vertex_df$ego[closeness_min])," (number: ",closeness_min,"). This measures how many steps is required to access every other vertex from a given
vertex."))
reciprocity_complete<-reciprocity(graph_complete)
reciprocity_complete
reciprocity_complete<-reciprocity(graph_complete)
print(paste0("The network has a reciprocity of ",reciprocity_complete,". The measure of reciprocity defines the proporsion of mutual connections, in a directed graph."))
ecount_complete
vcount_complete
density_complete
density_complete<-edge_density(graph_complete)
density_complete<-edge_density(graph_complete)
print(paste0("The network has a density of ",density_complete,". This measure is the ratio of the number of edges and the number of possible edges."))
reachability <- function(g, m) {
reach_mat = matrix(nrow = vcount(g), ncol = vcount(g))
for (i in 1:vcount(g)) {
reach_mat[i,] = 0
this_node_reach <- subcomponent(g, (i - 1), mode = m)
for (j in 1:(length(this_node_reach))) {
alter = this_node_reach[j] + 1
reach_mat[i, alter] = 1}}
return(reach_mat)
}
V[graph_complete]
V(graph_complete)
V(graph_complete)[1]
reach_full_in <- reachability(V(graph_complete)[1], 'in')
matrix_complete
reach_full_in <- reachability(matrix_complete, 'in')
matrix_complete[1]
matrix_complete[1,1]
vcount_complete
g=graph_complete
m='in'
reach_mat = matrix(nrow = vcount(g), ncol = vcount(g))
reach_mat
i=1
reach_mat[i,] = 0
reach_mat
this_node_reach <- subcomponent(g, (i - 1), mode = m)
alter = this_node_reach[j]
reach_mat[i, alter] = 1}}
reachability <- function(g, m) {
reach_mat = matrix(nrow = vcount(g), ncol = vcount(g))
for (i in 1:vcount(g)) {
reach_mat[i,] = 0
this_node_reach <- subcomponent(g, (i - 1), mode = m)
for (j in 1:(length(this_node_reach))) {
alter = this_node_reach[j]
reach_mat[i, alter] = 1}}
return(reach_mat)
}
reachability(graph_complete, 'in')
graph_complete
class(graph_complete)
graph_edge <- graph.data.frame(d = edge_indiv_df)
reach_full_in <- reachability(graph_edge, 'in')
V(graph_complete)
names(attributes)
# ecount_complete<-ecount(graph_complete)
# vcount_complete<-vcount(graph_complete)
sp_full_in <- shortest.paths(graph_complete, mode='in')
sp_full_in
View(sp_full_in)
reach_full_in <- reachability(graph_edge[1,], 'in')
graph_edge[1,]
summary(graph_edge[1,])
graph_edge[2,]
graph_edge[,1]
reachability <- function(g, m) {
reach_mat = matrix(nrow = vcount(g),
ncol = vcount(g))
for (i in 1:vcount(g)) {
reach_mat[i,] = 0
this_node_reach <- subcomponent(g, (i - 1), mode = m)
for (j in 1:(length(this_node_reach))) {
alter = this_node_reach[j]
reach_mat[i, alter] = 1
}
}
return(reach_mat)
}
reach_full_in <- reachability(graph_edge[,1], 'in')
reach_full_in <- reachability(graph_edge, 'in')
transitivity_complete<-transitivity(graph_complete)
transitivity_complete
print(paste0("The network has a transitivity of ",transitivity_complete,". This measure is the probability that the adjacent vertices of a vertex are connected. This is sometimes also called the clustering coefficient."))
this_node_reach <- subcomponent(g, (i), mode = m)
reach_full_in <- reachability(graph_edge, 'in')
alter = this_node_reach[j]+1
reachability <- function(g, m) {
reach_mat = matrix(nrow = vcount(g),
ncol = vcount(g))
for (i in 1:vcount(g)) {
reach_mat[i,] = 0
this_node_reach <- subcomponent(g, (i), mode = m)
for (j in 1:(length(this_node_reach))) {
alter = this_node_reach[j]+1
reach_mat[i, alter] = 1
}
}
return(reach_mat)
}
reach_full_in <- reachability(graph_edge, 'in')
alter = this_node_reach[j]
reachability <- function(g, m) {
reach_mat = matrix(nrow = vcount(g),
ncol = vcount(g))
for (i in 1:vcount(g)) {
reach_mat[i,] = 0
this_node_reach <- subcomponent(g, (i), mode = m)
for (j in 1:(length(this_node_reach))) {
alter = this_node_reach[j]
reach_mat[i, alter] = 1
}
}
return(reach_mat)
}
reach_full_in <- reachability(graph_edge, 'in')
reach_full_in
View(reach_full_in)
reach_full_in <- reachability(graph_edge[,1], 'in')
V(graph_edge)[1]
reach_full_in <- reachability(V(graph_edge)[1], 'in')
subcomponent(graph_edge, 1, mode = c("all", "out", "in"))
subcomponent(graph_edge, 1, mode = "in")
subcomponent(graph_edge, 1, mode = "out")
subcomponent(graph_edge, 1, mode = "all")
subcomponent(graph_edge, 1, mode = "in")
subcomponent(graph_edge, 2, mode = "in")
subcomponent(graph_edge, 3, mode = "in")
subcomponent(graph_edge, 4, mode = "in")
subcomponent(graph_edge, 5, mode = "in")
reach_full_in <- reachability(graph_complete, 'in')
reach_full_in[,1]
reach_full_in[,2]
reach_full_in[,3]
reach_full_in[,300]
sum(reach_full_in[,300])
sum(reach_full_in[,1])
sum(reach_full_in[,2])
sum(reach_full_in[,3])
sum(reach_full_in[,4])
sum(reach_full_in[,5])
i=1
length(subcomponent(graph_edge, i, mode = "in"))
length(V(graph_complete)
)
print(length(subcomponent(graph_edge, i, mode = "in")))
for(i in 1:length(V(graph_complete))){
print(length(subcomponent(graph_edge, i, mode = "in")))
}
stats_overall_graph<-ls(pattern = "_stat_")
#Graph-wide statistics
diameter_stat_complete<-diameter(graph_complete)
print(paste0("The network has a diameter of ",diameter_complete,". This measure is the length of the longest geodesic (the largest distance between any two vertices in a connected graph)."))
reciprocity_stat_complete<-reciprocity(graph_complete)
print(paste0("The network has a reciprocity of ",reciprocity_complete,". The measure of reciprocity defines the proportion of mutual connections, in a directed graph."))
density_stat_complete<-edge_density(graph_complete)
print(paste0("The network has a density of ",density_complete,". This measure is the ratio of the number of edges and the number of possible edges."))
transitivity_stat_complete<-transitivity(graph_complete)
print(paste0("The network has a transitivity of ",transitivity_complete,". This measure is the probability that the adjacent vertices of a vertex are connected. This is sometimes also called the clustering coefficient."))
stats_overall_graph<-ls(pattern = "_stat_")
stats_overall_graph
stats_overall_graph<-ls(pattern = "_stat_")
stats_overall_graph
#Graph-wide statistics
Diameter_stat_complete<-diameter(graph_complete)
print(paste0("The network has a diameter of ",Diameter_stat_complete,". This measure is the length of the longest geodesic (the largest distance between any two vertices in a connected graph)."))
Reciprocity_stat_complete<-reciprocity(graph_complete)
print(paste0("The network has a reciprocity of ",Reciprocity_stat_complete,". The measure of reciprocity defines the proportion of mutual connections, in a directed graph."))
Density_stat_complete<-edge_density(graph_complete)
print(paste0("The network has a density of ",Density_stat_complete,". This measure is the ratio of the number of edges and the number of possible edges."))
Transitivity_stat_complete<-transitivity(graph_complete)
print(paste0("The network has a transitivity of ",Transitivity_stat_complete,". This measure is the probability that the adjacent vertices of a vertex are connected. This is sometimes also called the clustering coefficient."))
stats_overall_graph<-ls(pattern = "_stat_")
stats_overall_graph
strsplit(stats_overall_graph[1])
strsplit(stats_overall_graph[1],"_")
strsplit(stats_overall_graph[1],"_")[1]
strsplit(stats_overall_graph[1],"_")[[1]][1]
strsplit(stats_overall_graph[2],"_")[[1]][1]
strsplit(stats_overall_graph[3],"_")[[1]][1]
strsplit(stats_overall_graph[k],"_")[[1]][1]
stats_overall_graph<-ls(pattern = "_stat_")
stat_overall_names<-vector()
for(k in 1:length(stats_overall_graph)){
stat_overall_names<-c(stat_overall_names,strsplit(stats_overall_graph[k],"_")[[1]][1])
}
stat_overall_names
stats_overall_graph
unlist(stats_overall_graph,use.names=F)
unlist(stats_overall_graph[1],use.names=F)
unlist(stats_overall_graph[1])
stats_overall_graph[1]
unname(stats_overall_graph[1],use.names=F)
unname(stats_overall_graph[1])
as.integer(stats_overall_graph[1])
as.numeric(stats_overall_graph[1])
stats_overall_graph[1]
stats_overall_graph[[1]]
as.numeric(paste(unlist(stats_overall_graph))
)
stats_overall_graph
as.numeric((unlist(stats_overall_graph)))
v1 <- unlist(stats_overall_graph)
v1
ls()
ls([1], envir=.GlobalEnv)
ls(stats_overall_graph[1], envir=.GlobalEnv)
stats_overall_graph[1]
ls(stats_overall_graph[1], envir=.GlobalEnv)
ls(stats_overall_graph[[1]], envir=.GlobalEnv)
#Determine Keyplayers via different statistical mesurements
## Set size of set group to number of keyplayers wanted per metric
kpset(matrix_complete, size = 1, type = "degree", cmode = "indegree", method = "max")
rownames(matrix_complete)[177] #from second model in first group above.
kp_in_degree_parallel<-kpset(matrix_complete, size = 1, type = "degree", cmode = "indegree", parallel = TRUE,cluster = 2)
rownames(matrix_complete)[kp_in_degree_parallel$keyplayers[1]] #from second model in first group above.
kp_in_degree_parallel<-kpset(matrix_complete, size = keyplayer_num, type = "degree", cmode = "indegree", parallel = TRUE,cluster = 2)
#Determine Keyplayers via different statistical mesurements
## Set size of set group to number of keyplayers wanted per metric
keyplayer_num<-3
kp_in_degree_parallel<-kpset(matrix_complete, size = keyplayer_num, type = "degree", cmode = "indegree", parallel = TRUE,cluster = 2)
kp_in_degree_parallel<-kpset(matrix_complete, size = keyplayer_num, type = "degree", cmode = "indegree", parallel = TRUE,cluster = 2)
kp_in_mreach_close<-kpset(matrix_inv_non_zero, size = keyplayer_num, type = "mreach.closeness", cmode = "indegree", M = 1)

ptm <- proc.time()
##################
#Bryan's For() loop solution
for(i in 1:100){
if((i/3) == as.integer(i/3) & (i/5) == as.integer(i/5)){
print("FizzBuzz")
}else if (!(i/3) == as.integer(i/3) & (i/5) == as.integer(i/5)){
print("Buzz")
}else if((i/3) == as.integer(i/3) & !(i/5) == as.integer(i/5)){
print("Fizz")
}else{
print(i)
}
}
##################
proc.time() - ptm
##################
##################
ptm <- proc.time()
##################
#Angela's For() loop solution
for(i in 1:100){
output=""
if((i/3) == as.integer(i/3)){output=paste0(output,"Fizz")}
if((i/5) == as.integer(i/5)){output=paste0(output,"Buzz")}
if(output==""){print(i)}else{print(output)}
}
##################
proc.time() - ptm
##################
##################
ptm <- proc.time()
##################
#Alec's Mutate vector solution
seq<-data.frame(seq(1:100))
fizz<-function(i){ifelse(as.integer(i/3)==i/3,"fizz",i)}
buzz<-function(i){ifelse(as.integer(i/5)==i/5,"buzz",i)}
fizzbuzz<-function(fizz,buzz){ifelse(fizz=="fizz" & buzz=="buzz","fizzbuzz",
ifelse(fizz==buzz,fizz,ifelse(fizz=="fizz",fizz,buzz)))}
seq_fizzbuzz <- mutate(seq, fizz_i = fizz(seq.1.100.),buzz_i=buzz(seq.1.100.),fizzbuzz_i=fizzbuzz(fizz_i,buzz_i))
print(seq_fizzbuzz$fizzbuzz_i)
##################
proc.time() - ptm
##################
library(igraph)
# read.table() is the most common R command for loading data from
# files in which values are in tabular format. The function loads
# the table into a data frame object, which is the basic data type
# for most operations in R. By default, R assumes that the table
# has no header and is delimited by any white space; these
# settings are fine for our purposes here.
#
# One handy aspect of R is that you can read in data from a URL
# directly by referencing the URL in the read.table() function,
# as follows:
advice_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt')
friendship_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Friendship.txt')
reports_to_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-ReportsTo.txt')
source("http://sna.stanford.edu/setup.R")
10000*e^(-.35)
10000*exp(-.35)
pop<-as.data.frame(10000)
pop<-as.data.frame(10000)
pop[1]
pop[1]*exp(-.35)
pop<-rbind(pop,pop.i)
pop.i<-pop[1]*exp(-.35)
pop<-rbind(pop,pop.i)
View(pop)
pop<-as.data.frame(10000)
for(i in 1:7){
pop.i<-pop[1]*exp(-.35)
pop<-rbind(pop,pop.i)
}
View(pop)
pop<-as.data.frame(10000)
for(i in 1:7){
pop.i<-pop[i]*exp(-.35)
pop<-rbind(pop,pop.i)
}
View(pop)
i=1
pop<-as.data.frame(10000)
pop.i<-pop[i]*exp(-.35)
pop<-rbind(pop,pop.i)
i=2
pop.i<-pop[i]*exp(-.35)
pop.i<-pop[i,]*exp(-.35)
pop<-rbind(pop,pop.i)
pop<-as.data.frame(10000)
for(i in 1:7){
pop.i<-pop[i,]*exp(-.35)
pop<-rbind(pop,pop.i)
}
View(pop)
(-12.2) + (3.2*ln(300))
(-12.2) + (3.2*log(300))
exp((-12.2) + (3.2*log(300)))
1.35*300*exp(-0.001*300)
############################
#Type in the base directory and input datapaths below
basedirectory <- "/Users/alecnelson/Documents/GitHub/ICON8002_SNA"
input_datapath <- "/Users/alecnelson/Documents/GitHub/ICON8002_SNA/Data"
vertex_datapath <- "vertex_df.csv"
edge_indiv_datapath <- "edge_indiv_df.csv"
edge_org_datapath <- "edge_org_df.csv"
setwd(input_datapath)
#List packages used
list.of.packages <- c("igraph","randomNames","fabricatr","plyr","RColorBrewer","keyplayer","sna")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){install.packages(new.packages)}
#Load all packages
lapply(list.of.packages, require, character.only = TRUE)
vertex_df <- read.csv(vertex_datapath, header=T, row.names = 1)
############################
#Type in the base directory and input datapaths below
basedirectory <-
input_datapath <-
vertex_datapath <- "vertex_test_df.csv"
edge_indiv_datapath <- "edge_indiv_test_df.csv"
edge_org_datapath <- "edge_org_test_df.csv"
vertex_df <- read.csv(vertex_datapath, header=T, row.names = 1)
edge_indiv_df <- read.csv(edge_indiv_datapath, header=T, row.names = 1)
edge_org_df <- read.csv(edge_org_datapath, header=T, row.names = 1)
########################################################
# Before we merge these data, we need to make sure 'ego' and 'alter' are the
# same across data sets. We can compare each row using the == syntax.
# The command below should return TRUE for every row if all ego rows
# are the same :
unique(as.character(vertex_df$ego)) == unique(c(as.character(edge_indiv_df$ego),as.character(edge_indiv_df$alter)))
#Combine edge and vertex attribute information into igraph format
graph_complete <- graph.data.frame(d = edge_indiv_df, vertices = vertex_df)
#Symmetrize graph to remove directed edges
graph_complete_symmetrized <- as.undirected(graph_complete, mode='collapse')
# Simplify graph to remove loops and prepare variables
graph_complete_simpl <- simplify(graph_complete)
graph_complete_simpl_symm <- as.undirected(graph_complete_simpl, mode='collapse')
in.degree<-igraph::degree(graph_complete,mode="in")
summary(graph_complete)
graph_complete
V(graph_complete)$profession.df
igraph::get.vertex.attribute(graph_complete,'profession.df')
unique(igraph::get.vertex.attribute(graph_complete,'profession.df'))
plot.network.original <- plot(graph_complete_simpl,
layout = layout.fruchterman.reingold,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
#vertex.color=profession.colors,
#vertex.size=((in.degree)*1.5),
vertex.size=5,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="Network Plot (Generated Data)",
#frame=TRUE,
margin=0.0001)
in.degree
plot.network.original <- plot(graph_complete_simpl,
layout = layout.fruchterman.reingold,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
#vertex.color=profession.colors,
vertex.size=((in.degree)*1.5),
#vertex.size=5,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="Network Plot (Generated Data)",
#frame=TRUE,
margin=0.0001)
plot(graph_complete_simpl,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
#vertex.color=profession.colors,
#vertex.size=((in.degree)*1.5),
vertex.size=5,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="Network Plot_Nicely",
#frame=TRUE,
margin=0.0001,
layout = layout_nicely)
### Plot network by Profession (colors)
### Nicely layout, simplified (i.e., no loops), directed, vertices colored by profession
layout.graph <- layout_(graph_complete_simpl, nicely())
layout.graph<-norm_coords(layout.graph, ymin=-1, ymax=1, xmin=-1, xmax=1)
## Playing around with colors
display.brewer.all()
colr.palette <- brewer.pal(n = 9, name = "Spectral")
profession.colors <- colr.palette[vertex.test.df$profession.df]
profession.colors <- colr.palette[vertex_df$profession.df]
unique(profession.colors)
plot(graph_complete_simpl,
layout = layout.graph,
rescale = F,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
vertex.color=profession.colors,
#vertex.size=((in.degree)*1.5),
vertex.size=5,
vertex.label=NA,
vertex.label.cex=0.5,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="SNA by Profession",
#frame=TRUE,
margin = 0.0001)
legend(x=-1.5, y = -0.85, legend = levels(vertex_df$profession),
col = profession.colors, pch=19, pt.cex=0.8, cex=0.8, bty="n", ncol=1)
legend(x=-1.5, y = -0.85, legend = levels(vertex_df$profession),
col = profession.colors, pch=19, pt.cex=0.8, cex=0.8, bty="n", ncol=1)
#### NOTE: Need to figure out colors between vertices and legend. Don't currently match - BB 10.18.18
V(graph_complete_symmetrized)$community <- vertex_df$profession.df
colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen","blue","pink","green","purple"), alpha=.6)
plot(graph_complete_symmetrized, vertex.color=colrs[V(graph_complete_symmetrized)$community], vertex.label)
plot(graph_complete_symmetrized, vertex.color=colrs[V(graph_complete_symmetrized)$community], vertex.label=vertex_df$profession.df)
V(graph_complete_symmetrized)$community <- V(graph_complete)$profession.df
colrs <- adjustcolor( c("red", "tomato", "gold", "yellowgreen","blue","pink","green","purple","grey50"), alpha=.6)
plot(graph_complete_symmetrized, vertex.color=colrs[V(graph_complete_symmetrized)$community])
### Plotting by community/profession with vertices weighted by in.degree
V(graph_complete_symmetrized)$community <- vertex_df$profession.df
colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen","blue","pink","green","purple"), alpha=.6)
plot(graph_complete_symmetrized,
#edge.color=edge_test$connection,
edge.arrow.size=.5,
vertex.color=colrs[V(graph_complete_symmetrized)$community],
vertex.size=((in.degree)*1.5),
vertex.color=colrs,
#vertex.size=((in.degree)*1.5),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession/community)',
#frame=TRUE,
margin=0.0001)
plot(graph_complete_simpl,
layout = layout.graph,
rescale = F,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
vertex.color=vertex.test.df$profession.df,
#vertex.size=((in.degree)*1.5),
vertex.size=igraph::degree(graph_complete_simpl),
vertex.label=NA,
vertex.label.cex=0.5,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="SNA Vertices Weighted by Degree",
#frame=TRUE,
margin = 0.0001)
plot(graph_complete_simpl,
layout = layout.graph,
rescale = F,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
vertex.color=igraph::get.vertex.attribute(graph_complete,'profession.df'),
#vertex.size=((in.degree)*1.5),
vertex.size=igraph::degree(graph_complete_simpl),
vertex.label=NA,
vertex.label.cex=0.5,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="SNA Vertices Weighted by Degree",
#frame=TRUE,
margin = 0.0001)
plot(graph_complete_simpl,
layout = layout.graph,
rescale = F,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
#vertex.color=vertex.test.df$profession.df,
#vertex.size=((in.degree)*1.5),
vertex.size=igraph::degree(graph_complete_simpl),
vertex.label=NA,
vertex.label.cex=0.5,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main="SNA Vertices Weighted by Degree",
#frame=TRUE,
margin = 0.0001)
cut.off <- round(mean(edge_indiv_df$q3.years.worked.with.eiq))
graph_complete.years <- delete_edges(graph_complete, E(graph_complete)[q3.years.worked.with.eiq<cut.off])
layout.graph <- layout_(graph_complete.years, nicely())
layout.graph<-norm_coords(layout.graph, ymin=-1, ymax=1, xmin=-1, xmax=1)
plot(graph_complete.years,
layout=(layout.graph*1.1),
rescale=F,
#edge.color=edge_test$connection,
edge.arrow.size=.01,
vertex.color=vertex_df$profession,
#vertex.size=((in.degree)*0.9),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.6,
vertex.label.dist=1,
vertex.label.degree=-0.6,
main=paste0('Network of worked-together-with ',cut.off,' years connection'),
#frame=TRUE,
margin=0.0001)
#Clustering function to add weights to edges with shared profession
G_Grouped = graph_complete_symmetrized
E(G_Grouped)$weight = 1
professions.list<-unique(V(G_Grouped)$profession.df)
## Add edges with high weight between all nodes in the same group
for(i in 1:length(professions.list)) {
GroupV = which(V(G_Grouped)$profession.df == professions.list[i])
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=5))
print(paste0("Ran loop for profession ",professions.list[i]))
}
## Now create a layout based on G_Grouped
LO = layout_with_fr(G_Grouped)
LO<-norm_coords(LO, ymin=-1, ymax=1, xmin=-1, xmax=1)
plot(graph_complete_symmetrized,
layout=(LO*1.0),
rescale=F,
#edge.color=edge_test$connection,
edge.arrow.size=.5,
vertex.color=vertex_df$profession.df,
#vertex.size=((in.degree)*0.7),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.color= adjustcolor("black", 0.6),
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession)',
#frame=TRUE,
margin=0.0001)
#Clustering function to add weights to edges with shared profession
G_Grouped = graph_complete_symmetrized
E(G_Grouped)$weight = 1
professions.list<-unique(V(G_Grouped)$profession.df)
## Add edges with high weight between all nodes in the same group
for(i in 1:length(professions.list)) {
GroupV = which(V(G_Grouped)$profession.df == professions.list[i])
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=2))
print(paste0("Ran loop for profession ",professions.list[i]))
}
## Now create a layout based on G_Grouped
LO = layout_with_fr(G_Grouped)
LO<-norm_coords(LO, ymin=-1, ymax=1, xmin=-1, xmax=1)
plot(graph_complete_symmetrized,
layout=(LO*1.0),
rescale=F,
#edge.color=edge_test$connection,
edge.arrow.size=.5,
vertex.color=vertex_df$profession.df,
#vertex.size=((in.degree)*0.7),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.color= adjustcolor("black", 0.6),
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession)',
#frame=TRUE,
margin=0.0001)
#Clustering function to add weights to edges with shared profession
G_Grouped = graph_complete_symmetrized
E(G_Grouped)$weight = 1
professions.list<-unique(V(G_Grouped)$profession.df)
## Add edges with high weight between all nodes in the same group
for(i in 1:length(professions.list)) {
GroupV = which(V(G_Grouped)$profession.df == professions.list[i])
G_Grouped = add_edges(G_Grouped, combn(GroupV, 2), attr=list(weight=1.5))
print(paste0("Ran loop for profession ",professions.list[i]))
}
## Now create a layout based on G_Grouped
LO = layout_with_fr(G_Grouped)
LO<-norm_coords(LO, ymin=-1, ymax=1, xmin=-1, xmax=1)
plot(graph_complete_symmetrized,
layout=(LO*1.0),
rescale=F,
#edge.color=edge_test$connection,
edge.arrow.size=.5,
vertex.color=vertex_df$profession.df,
#vertex.size=((in.degree)*0.7),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.color= adjustcolor("black", 0.6),
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession)',
#frame=TRUE,
margin=0.0001)
#Add graph of strong/weak connections between professional groups
V(graph_complete_symmetrized)$profession.df
E(graph_complete_symmetrized)$profession.df
strength(graph_complete_symmetrized)
graph_attr(graph_complete_symmetrized)
E(graph_complete)[inc(V(graph_complete)[profession.df==professions.list[1]])]
plot(g2,
layout=layout_in_circle,
rescale=T,
edge.color=adjustcolor("black", 0.1),
edge.arrow.size=0.1,
vertex.color=vertex_df$profession.df,
#vertex.size=((in.degree)*0.7),
vertex.size=3,
#vertex.label=vertex_df$profession.df,
vertex.label=NA,
vertex.label.cex=0.7,
vertex.label.color= adjustcolor("black", 0.5),
vertex.label.dist=1,
vertex.label.degree=-0.6,
main='Test Data Connections (color by profession)',
#frame=TRUE,
margin=0.0001)
#Contract verticies to professional interactions
professions_interactions <- contract(graph_complete, mapping = as.numeric(mapvalues(vertex_df$profession.df, from = professions.list, to = 1:length(professions.list))))
#Simplify to remove loops and self-connections within-group
professions_interactions<-simplify(professions_interactions)
degree_complete<-igraph::degree(graph_complete)
degree_max<-which.max(igraph::degree(graph_complete))
degree_min<-which.min(igraph::degree(graph_complete))
diameter_complete<-diameter(graph_complete)
closeness_complete<-igraph::closeness(graph_complete)
reciprocity_complete<-reciprocity(graph_complete)
ecount_complete<-ecount(graph_complete)
vcount_complete<-vcount(graph_complete)
density_complete<-edge_density(graph_complete)
reachability <- function(g, m) {
reach_mat = matrix(nrow = vcount(g),
ncol = vcount(g))
for (i in 1:vcount(g)) {
reach_mat[i,] = 0
this_node_reach <- subcomponent(g, (i - 1), mode = m)
for (j in 1:(length(this_node_reach))) {
alter = this_node_reach[j] + 1
reach_mat[i, alter] = 1
}
}
return(reach_mat)
}
reach_full_in <- reachability(krack_full, 'in')
reach_full_in <- reachability(graph_complete, 'in')
reach_full_in <- reachability(graph_complete_symmetrized, 'in')
########################################################
#Keyplayer functions:
matrix_complete<-as.matrix(as_adjacency_matrix(graph_complete))
sna::degree(matrix_complete)
########################################################
#Keyplayer functions:
#Convert igraph object into matrix object, which can be read by sna package
matrix_complete<-as.matrix(as_adjacency_matrix(graph_complete))
matrix_inv_non_zero <- matrix_complete
# Inverse the non-zero tie status
matrix_inv_non_zero[matrix_complete != 0] <- 1 / matrix_complete[matrix_complete != 0]
# Symmetrized version of matrix
matrix_complete_symm <- symmetrize(matrix_complete)
#Setting all zero ties to 1
matrix_non_zero_one <- matrix_complete
matrix_non_zero_one[matrix_complete != 0] <- 1
evcent(matrix_inv_non_zero, gmode = "digraph", ignore.eval = FALSE, use.eigen = TRUE)
evcent(matrix_complete_symm)
fragment(matrix_inv_non_zero)
mreach.degree(matrix_complete, M = 1)
which.max(mreach.degree(matrix_complete, M = 1)[,3])[1]
mreach.closeness(matrix_inv_non_zero)
which.max(mreach.closeness(matrix_inv_non_zero)[,3])[1]
#Determine Keyplayers via different statistical mesurements
## Set size of set group to number of keyplayers wanted per metric
kpset(matrix_complete, size = 1, type = "degree", cmode = "indegree", method = "max")
plot(graph_complete_simpl,
layout=layout.graph,
rescale=T,
#edge.color=edge_test$connection,
edge.arrow.size=.1,
vertex.color=ifelse(vertex_df$ego == as.character(vertex_df$ego[177]), "Firebrick1", "Gray60"),
#vertex.size=((in.degree)*1.5),
#vertex.size=(igraph::degree(graph_complete)*0.5),
vertex.size=ifelse(vertex_df$ego == as.character(vertex_df$ego[177]), 8, 4),
vertex.label= ifelse(vertex_df$ego == as.character(vertex_df$ego[177]), as.character(vertex_df$ego), NA),
#label.color = "Firebrick1",
vertex.label=NA,
vertex.label.cex=ifelse(vertex_df$ego == as.character(vertex_df$ego[177]), .5, NA),
vertex.label.dist=0,
vertex.label.degree=0,
main='SNA with Key Player',
#frame=TRUE,
margin=0.0001)
#Display information as matrix format
graph_complete[]
#Display information as matrix format
#graph_complete[]
matrix_complete<-as.matrix(as_adjacency_matrix(graph_complete))
Keyplayer.list<-c(2,4,5,9,14,16,17,18,28,63,67)
data_logistic_test<-vertex_df
Keyplay.bool=ifelse(rownames(data_logistic_df) %in% Keyplayer.list,1,0)
data_logistic_df<-vertex_df
Keyplay.bool=ifelse(rownames(data_logistic_df) %in% Keyplayer.list,1,0)
data_logistic_df<-cbind(Keyplay.bool,data_logistic_df)
colnames(data_logistic_df)
data_logistic_df <- subset(data_logistic_df,
select=c(1,3,10,11,12,13,14,15))
model <- glm(Keyplay.bool ~.,family=binomial(link='logit'),data=data_logistic_df)
summary(model)
############################
basedirectory <-
setwd(basedirectory)

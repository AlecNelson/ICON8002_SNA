points(1, type="b", pch=2)
points(1, type="b", pch=1)
points(1, type="b", pch=1, col=1)
points(1, pch=1, col=1)
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
points(1, pch=1, col=1)
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(1, pch=i, col=i)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(1:25, pch=i, col=i)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(1,i, pch=i, col=i)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(i,1, pch=i, col=i)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2)+0.2)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2)+1)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2)+1)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2)+1)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(2,2,1,1)+1)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(2,2,1,1)+2.5)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=i)
}
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
library(ggplot2)
install.packages("ggplot2")
install.packages("ggplot2")
library(ggplot2)
install.packages("ggplot2")
install.packages("scales")
install.packages("scales")
install.packages("ggplot2")
install.packages("rlang")
install.packages("ggplot2")
install.packages("ggplot2")
x <- seq(-4, 4, length=100)
hx <- dnorm(x)
degf <- c(1, 3, 8, 30)
colors <- c("red", "blue", "darkgreen", "gold", "black")
labels <- c("df=1", "df=3", "df=8", "df=30", "normal")
plot(x, hx, type="l", lty=2, xlab="x value",
ylab="Density", main="Comparison of t Distributions")
for (i in 1:4){
lines(x, dt(x,degf[i]), lwd=2, col=colors[i])
}
legend("topright", inset=.05, title="Distributions",
labels, lwd=2, lty=c(1, 1, 1, 1, 2), col=colors)
x <- seq(-4, 4, length=100)
hx <- dnorm(x)
degf <- c(1, 3, 8, 30)
colors <- c("red", "blue", "darkgreen", "gold", "black")
labels <- c("df=1", "df=3", "df=8", "df=30", "normal")
plot(x, hx, type="l", lty=2, xlab="x value",
ylab="Density", main="Comparison of t Distributions")
for (i in 1:4){
lines(x, dt(x,degf[i]), lwd=2, col=colors[i])
}
dbeta(x, shape1, shape2, ncp = 0, log = FALSE)
dbeta(x, 0.5, 0.5, ncp = 0, log = FALSE)
plot(dbeta(x, 0.5, 0.5, ncp = 0, log = FALSE))
plot(dbeta(x, 0.5, 0.5, ncp = 0, log = FALSE),type="l")
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(0.00,1.00), ylim=c(0.00,2.5),xlab="X", ylab="Density")
lines(dbeta(x, 0.5, 0.5, ncp = 0, log = FALSE))
lines(dbeta(x, 0.5, 0.5, log = FALSE))
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(0.00,1.00), ylim=c(0.00,2.5),xlab="X", ylab="Density")
lines(dbeta(x, 0.5, 0.5, log = FALSE))
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(0.00,1.00), ylim=c(0.00,2.5),xlab="X", ylab="Density")
lines(pbeta(x, 0.5, 0.5, log = FALSE))
pbeta(x, 0.5, 0.5, log = FALSE)
p = seq(0,1, length=100)
p = seq(0,1, length=100)
plot(p, dbeta(p, 100, 100), ylab="density", type ="l", col=4)
lines(p, dbeta(p, 10, 10), type ="l", col=3)
lines(p, dbeta(p, 2, 2), col=2)
lines(p, dbeta(p, 1, 1), col=1)
legend(0.7,8, c("Be(100,100)","Be(10,10)","Be(2,2)", "Be(1,1)"),lty=c(1,1,1,1),col=c(4,3,2,1))
p = seq(0,1, length=100)
plot(p, dbeta(p, 0.5, 0.5), ylab="density", type ="l", lty=2)
lines(p, dbeta(p, 0.5, 2.0), type ="l", col="grey")
lines(p, dbeta(p, 2.0, 0.5), lty=4)
lines(p, dbeta(p, 2.0, 2.0), lty=2,col="grey")
par(mar=c(2,2,1,1)+2)
p = seq(0,1, length=100)
plot(p, dbeta(p, 0.5, 0.5), ylab="Density",xlab="X", xlim=c(0.00,1.00), ylim=c(0.00,2.5),type ="l", lty=2)
lines(p, dbeta(p, 0.5, 2.0), type ="l", col="grey")
lines(p, dbeta(p, 2.0, 0.5), lty=4)
lines(p, dbeta(p, 2.0, 2.0), lty=2,col="grey")
library(igraph)
# read.table() is the most common R command for loading data from
# files in which values are in tabular format. The function loads
# the table into a data frame object, which is the basic data type
# for most operations in R. By default, R assumes that the table
# has no header and is delimited by any white space; these
# settings are fine for our purposes here.
#
# One handy aspect of R is that you can read in data from a URL
# directly by referencing the URL in the read.table() function,
# as follows:
advice_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt')
friendship_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Friendship.txt')
reports_to_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-ReportsTo.txt')
View(advice_data_frame)
# For convenience, we can assign column names to our newly
# imported data frames. c() is a common generic R function that
# combines its arguments into a single vector.
colnames(advice_data_frame) <- c('ego', 'alter', 'advice_tie')
head(advice_data_frame)
colnames(friendship_data_frame) <- c('ego', 'alter', 'friendship_tie')
head(friendship_data_frame)
colnames(reports_to_data_frame) <- c('ego', 'alter', 'reports_to_tie')
head(reports_to_data_frame)
View(advice_data_frame)
# Take a look at each data frame using the 'fix()" function. Note that you'll
# need to close each fix window before R will evaluate the next line of code.
fix(advice_data_frame)
# Now that we've verified they are all the same, we can combine them into
# a single data frame.
krack_full_data_frame <- cbind(advice_data_frame,
friendship_data_frame$friendship_tie,
reports_to_data_frame$reports_to_tie)
head(krack_full_data_frame)
names(krack_full_data_frame)[4:5] <- c("friendship_tie",
"reports_to_tie")
head(krack_full_data_frame)
# Another way to build the data frame is to use R's
# data.frame syntax from the start:
krack_full_data_frame <- data.frame(ego = advice_data_frame[,1],
alter = advice_data_frame[,2],
advice_tie = advice_data_frame[,3],
friendship_tie = friendship_data_frame[,3],
reports_to_tie = reports_to_data_frame[,3])
head(krack_full_data_frame)
View(krack_full_data_frame)
View(krack_full_data_frame)
library(igraph)
# read.table() is the most common R command for loading data from
# files in which values are in tabular format. The function loads
# the table into a data frame object, which is the basic data type
# for most operations in R. By default, R assumes that the table
# has no header and is delimited by any white space; these
# settings are fine for our purposes here.
#
# One handy aspect of R is that you can read in data from a URL
# directly by referencing the URL in the read.table() function,
# as follows:
advice_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt')
source("http://sna.stanford.edu/setup.R")
advice_data_frame
#FIZZBUZZ TEST
##################
ptm <- proc.time()
##################
#Alec's For() loop solution
for(i in 1:100){
if((i/3) == as.integer(i/3) & !(i/5) == as.integer(i/5)){
print("Fizz")
}else if (!(i/3) == as.integer(i/3) & (i/5) == as.integer(i/5)){
print("Buzz")
}else if((i/3) == as.integer(i/3) & (i/5) == as.integer(i/5) & (i/15) == as.integer(i/15)){
print("FizzBuzz")
}else{
print(i)
}
}
##################
proc.time() - ptm
##################
##################
ptm <- proc.time()
##################
#Bryan's For() loop solution
for(i in 1:100){
if((i/3) == as.integer(i/3) & (i/5) == as.integer(i/5)){
print("FizzBuzz")
}else if (!(i/3) == as.integer(i/3) & (i/5) == as.integer(i/5)){
print("Buzz")
}else if((i/3) == as.integer(i/3) & !(i/5) == as.integer(i/5)){
print("Fizz")
}else{
print(i)
}
}
##################
proc.time() - ptm
##################
##################
ptm <- proc.time()
##################
#Angela's For() loop solution
for(i in 1:100){
output=""
if((i/3) == as.integer(i/3)){output=paste0(output,"Fizz")}
if((i/5) == as.integer(i/5)){output=paste0(output,"Buzz")}
if(output==""){print(i)}else{print(output)}
}
##################
proc.time() - ptm
##################
##################
ptm <- proc.time()
##################
#Alec's Mutate vector solution
seq<-data.frame(seq(1:100))
fizz<-function(i){ifelse(as.integer(i/3)==i/3,"fizz",i)}
buzz<-function(i){ifelse(as.integer(i/5)==i/5,"buzz",i)}
fizzbuzz<-function(fizz,buzz){ifelse(fizz=="fizz" & buzz=="buzz","fizzbuzz",
ifelse(fizz==buzz,fizz,ifelse(fizz=="fizz",fizz,buzz)))}
seq_fizzbuzz <- mutate(seq, fizz_i = fizz(seq.1.100.),buzz_i=buzz(seq.1.100.),fizzbuzz_i=fizzbuzz(fizz_i,buzz_i))
print(seq_fizzbuzz$fizzbuzz_i)
##################
proc.time() - ptm
##################
library(igraph)
# read.table() is the most common R command for loading data from
# files in which values are in tabular format. The function loads
# the table into a data frame object, which is the basic data type
# for most operations in R. By default, R assumes that the table
# has no header and is delimited by any white space; these
# settings are fine for our purposes here.
#
# One handy aspect of R is that you can read in data from a URL
# directly by referencing the URL in the read.table() function,
# as follows:
advice_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt')
friendship_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Friendship.txt')
reports_to_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-ReportsTo.txt')
source("http://sna.stanford.edu/setup.R")
10000*e^(-.35)
10000*exp(-.35)
pop<-as.data.frame(10000)
pop<-as.data.frame(10000)
pop[1]
pop[1]*exp(-.35)
pop<-rbind(pop,pop.i)
pop.i<-pop[1]*exp(-.35)
pop<-rbind(pop,pop.i)
View(pop)
pop<-as.data.frame(10000)
for(i in 1:7){
pop.i<-pop[1]*exp(-.35)
pop<-rbind(pop,pop.i)
}
View(pop)
pop<-as.data.frame(10000)
for(i in 1:7){
pop.i<-pop[i]*exp(-.35)
pop<-rbind(pop,pop.i)
}
View(pop)
i=1
pop<-as.data.frame(10000)
pop.i<-pop[i]*exp(-.35)
pop<-rbind(pop,pop.i)
i=2
pop.i<-pop[i]*exp(-.35)
pop.i<-pop[i,]*exp(-.35)
pop<-rbind(pop,pop.i)
pop<-as.data.frame(10000)
for(i in 1:7){
pop.i<-pop[i,]*exp(-.35)
pop<-rbind(pop,pop.i)
}
View(pop)
(-12.2) + (3.2*ln(300))
(-12.2) + (3.2*log(300))
exp((-12.2) + (3.2*log(300)))
1.35*300*exp(-0.001*300)
############################
#Type in the base directory and input datapaths below
basedirectory <- "/Users/alecnelson/Documents/GitHub/ICON8002_SNA"
input_datapath <- "/Users/alecnelson/Documents/GitHub/ICON8002_SNA/Data"
############################
#Type in the base directory and input datapaths below
basedirectory <-
input_datapath <-
vertex_datapath <- "vertex_test_df_10_28_18.csv"
edge_indiv_datapath <- "edge_indiv_test_df_10_28_18.csv"
setwd(input_datapath)
#List packages used
list.of.packages <- c("igraph","randomNames","fabricatr","plyr","RColorBrewer","keyplayer","sna","MASS","naturalsort")
############################
#Type in the base directory and input datapaths below
basedirectory <- "/Users/alecnelson/Documents/GitHub/ICON8002_SNA"
input_datapath <- "/Users/alecnelson/Documents/GitHub/ICON8002_SNA/Data"
vertex_datapath <- "vertex_test_df_10_28_18.csv"
edge_indiv_datapath <- "edge_indiv_test_df_10_28_18.csv"
setwd(input_datapath)
#List packages used
list.of.packages <- c("igraph","randomNames","fabricatr","plyr","RColorBrewer","keyplayer","sna","MASS","naturalsort")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){install.packages(new.packages)}
#Load all packages
lapply(list.of.packages, require, character.only = TRUE)
vertex_df <- read.csv(vertex_datapath, header=T, row.names = 1)
edge_indiv_df <- read.csv(edge_indiv_datapath, header=T, row.names = 1)
########################################################
# Before we merge these data, we need to make sure 'ego' and 'alter' are the
# same across data sets. We can compare each row using the == syntax.
# The command below should return TRUE for every row if all ego rows
# are the same :
sort(unique(as.character(vertex_df$ego))) == sort(unique(c(as.character(edge_indiv_df$ego),as.character(edge_indiv_df$alter))))
#Combine edge and vertex attribute information into igraph format
graph_complete <- graph.data.frame(d = edge_indiv_df, vertices = vertex_df)
#Symmetrize graph to remove directed edges
graph_complete_symmetrized <- as.undirected(graph_complete, mode='collapse')
# Simplify graph to remove loops and prepare variables
graph_complete_simpl <- simplify(graph_complete)
graph_complete_simpl_symm <- as.undirected(graph_complete_simpl, mode='collapse')
in.degree<-igraph::degree(graph_complete,mode="in")
summary(graph_complete)
#Graph-wide statistics
Diameter_stat_complete<-diameter(graph_complete)
print(paste0("The network has a diameter of ",Diameter_stat_complete,". This measure is the length of the longest geodesic (the largest distance between any two vertices in a connected graph)."))
Reciprocity_stat_complete<-reciprocity(graph_complete)
print(paste0("The network has a reciprocity of ",Reciprocity_stat_complete,". The measure of reciprocity defines the proportion of mutual connections, in a directed graph."))
Density_stat_complete<-edge_density(graph_complete)
print(paste0("The network has a density of ",Density_stat_complete,". This measure is the ratio of the number of edges and the number of possible edges."))
Transitivity_stat_complete<-transitivity(graph_complete)
print(paste0("The network has a transitivity of ",Transitivity_stat_complete,". This measure is the probability that the adjacent vertices of a vertex are connected. This is sometimes also called the clustering coefficient."))
stats_overall_graph<-ls(pattern = "_stat_")
stat_overall_names<-vector()
for(k in 1:length(stats_overall_graph)){
stat_overall_names<-c(stat_overall_names,strsplit(stats_overall_graph[k],"_")[[1]][1])
}
cbind(stat_overall_names,as.data.frame(mget(stats_overall_graph)))
as.data.frame(mget(stats_overall_graph)
)
cbind(stat_overall_names,as.vector(mget(stats_overall_graph)))
Stat_overall_table<-cbind(stat_overall_names,as.vector(mget(stats_overall_graph)))
View(Stat_overall_table)
Stat_overall_table<-cbind(as.vector(stat_overall_names),as.vector(mget(stats_overall_graph)))
Stat_overall_table<-as.data.frame(cbind(as.vector(stat_overall_names),as.vector(mget(stats_overall_graph))))
View(Stat_overall_table)
Stat_overall_table<-as.data.frame(cbind(as.vector(stat_overall_names),as.vector(mget(stats_overall_graph))),row.names = FALSE)
View(Stat_overall_table)
names(Stat_overall_table)<-c("Statistic Name","Value")
View(Stat_overall_table)
#Individual statistics
#degree_complete<-igraph::degree(graph_complete)
Degree_max_stat_indiv<-which.max(igraph::degree(graph_complete))
print(paste0("The vertex with the greatest degree is ",as.character(vertex_df$ego[Degree_max_stat_indiv])," (number: ",Degree_max_stat_indiv,"). This measure is the number of its adjacent edges."))
Degree_min_stat_indiv<-which.min(igraph::degree(graph_complete))
print(paste0("The vertex with the fewest degree is ",as.character(vertex_df$ego[Degree_min_stat_indiv])," (number: ",Degree_min_stat_indiv,"). This measure is the number of its adjacent edges."))
#closeness_complete<-igraph::closeness(graph_complete)
Closeness_max_stat_indiv<-which.max(igraph::closeness(graph_complete))
print(paste0("The vertex with the greatest closeness is ",as.character(vertex_df$ego[Closeness_max_stat_indiv])," (number: ",Closeness_max_stat_indiv,"). This measures how many steps is required to access every other vertex from a given vertex."))
Closeness_min_stat_indiv<-which.min(igraph::closeness(graph_complete))
print(paste0("The vertex with the least closeness is ",as.character(vertex_df$ego[Closeness_min_stat_indiv])," (number: ",Closeness_min_stat_indiv,"). This measures how many steps is required to access every other vertex from a given vertex."))
stats_indiv_graph<-ls(pattern = "_stat_indiv")
stats_indiv_graph<-ls(pattern = "_stat_indiv")
stat_indiv_names<-vector()
for(k in 1:length(stats_indiv_graph)){
stat_indiv_names<-c(stat_indiv_names,strsplit(stats_indiv_graph[k],"_")[[1]][1])
}
stat_indiv_names
for(k in 1:length(stats_indiv_graph)){
stat_indiv_names<-c(stat_indiv_names,strsplit(stats_indiv_graph[k],"_")[[1]][2])
}
stat_indiv_names
stat_indiv_names<-vector()
for(k in 1:length(stats_indiv_graph)){
stat_indiv_names<-c(stat_indiv_names,strsplit(stats_indiv_graph[k],"_")[[1]][1:2])
}
stat_indiv_names
stat_overall_names
stats_overall_graph
stats_indiv_graph
stat_indiv_names
Stat_indiv_table<-as.data.frame(cbind(as.vector(stat_indiv_names),as.vector(mget(stats_indiv_graph))),row.names = FALSE)
Stat_indiv_table
k/2==integer(k/2)
(k/2)==(integer(k/2))
k
(k/2)==(as.integer(k/2)
)
k=3
(k/2)==(as.integer(k/2))
for(k in 1:length(stats_indiv_graph)){
stat_indiv_names<-c(stat_indiv_names,strsplit(stats_indiv_graph[k],"_")[[1]][1:2])
if((k/2)==(as.integer(k/2))){
stat_indiv_names[k-1]<-paste0(stat_indiv_names[k-1],stat_indiv_names[k])
}
}
stat_indiv_names
stat_indiv_names<-vector()
for(k in 1:length(stats_indiv_graph)){
stat_indiv_names<-c(stat_indiv_names,strsplit(stats_indiv_graph[k],"_")[[1]][1:2])
if((k/2)==(as.integer(k/2))){
stat_indiv_names[k-1]<-paste0(stat_indiv_names[k-1],"_",stat_indiv_names[k])
}
}
stat_indiv_names
length(stats_indiv_graph)
stats_indiv_graph
Stat_indiv_table<-as.data.frame(cbind(as.vector(stats_indiv_graph),as.vector(mget(stats_indiv_graph))),row.names = FALSE)
Stat_indiv_table
k=1
substr(stats_indiv_graph[k],1,(length(stats_indiv_graph[k])-6))
stats_indiv_graph[k]
substr(stats_indiv_graph[k],1,(length(stats_indiv_graph[k])-4))
substr(stats_indiv_graph[k],1,(length(stats_indiv_graph[k]))
)
substr(stats_indiv_graph[k],1,(length(stats_indiv_graph[k])+5)
)
(length(stats_indiv_graph[k])
)
(nchar(stats_indiv_graph[k])
)
substr(stats_indiv_graph[k],1,(nchar(stats_indiv_graph[k])-5))
substr(stats_indiv_graph[k],1,(nchar(stats_indiv_graph[k])-10))
substr(stats_indiv_graph[k],1,(nchar(stats_indiv_graph[k])-11)
)
stats_indiv_graph<-ls(pattern = "_stat_indiv")
stat_indiv_names<-vector()
for(k in 1:length(stats_indiv_graph)){
stat_indiv_names<-c(stat_overall_names,substr(stats_indiv_graph[k],1,(nchar(stats_indiv_graph[k])-11)))
}
Stat_indiv_table<-as.data.frame(cbind(as.vector(stats_indiv_graph),as.vector(mget(stats_indiv_graph))),row.names = FALSE)
names(Stat_indiv_table)<-c("Statistic Name","Value")
Stat_indiv_table
Stat_indiv_table<-as.data.frame(cbind(as.vector(stat_indiv_names),as.vector(mget(stats_indiv_graph))),row.names = FALSE)
stat_indiv_names
stat_indiv_names<-vector()
for(k in 1:length(stats_indiv_graph)){
stat_indiv_names<-c(stat_indiv_names,substr(stats_indiv_graph[k],1,(nchar(stats_indiv_graph[k])-11)))
}
Stat_indiv_table<-as.data.frame(cbind(as.vector(stat_indiv_names),as.vector(mget(stats_indiv_graph))),row.names = FALSE)
names(Stat_indiv_table)<-c("Statistic Name","Value")
Stat_indiv_table
indiv_vals<-as.vector(mget(stats_indiv_graph))
indiv_vals
stat_indiv_vertices<-vector()
indiv_vals<-as.vector(mget(stats_indiv_graph))
stat_indiv_vertices<-vector()
for(j in 1:length(indiv_vals)){
stat_indiv_vertices<-c(stat_indiv_vertices,as.character(vertex_df$ego[indiv_vals[j]]))
}
stat_indiv_vertices
as.character(vertex_df$ego[indiv_vals[j]])
indiv_vals[j]]
indiv_vals
indiv_vals<-as.numeric(as.vector(mget(stats_indiv_graph)))
indiv_vals
stat_indiv_vertices<-vector()
for(j in 1:length(indiv_vals)){
stat_indiv_vertices<-c(stat_indiv_vertices,as.character(vertex_df$ego[indiv_vals[j]]))
}
stat_indiv_vertices
Stat_indiv_table<-as.data.frame(cbind(as.vector(stat_indiv_names),stat_indiv_vertices,indiv_vals),row.names = FALSE)
names(Stat_indiv_table)<-c("Statistic Name","Vertex Name","Value")
Stat_indiv_table

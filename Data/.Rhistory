pb
pb <- progress_bar$new(
format = "  downloading [:bar] :percent eta: :eta",
total = 100, clear = FALSE, width= 60)
for (i in 1:100) {
pb$tick()
Sys.sleep(1 / 100)
}
pb <- progress_bar$new(
format = "  downloading [:bar] :percent eta: :eta",
total = 100, clear = FALSE, width= 60)
for (i in 1:100) {
pb$tick()
Sys.sleep(1 / 100)
print(i)
}
pb <- progress_bar$new(
format = "  downloading [:bar] :percent eta: :eta",
total = 100, clear = FALSE, width= 60)
for (i in 1:100) {
pb$tick()
Sys.sleep(1 / 10)
print(i)
}
pb <- progress_bar$new(
format = "[:bar] :percent eta: :eta",
total = 100, clear = FALSE, width= 60)
for (i in 1:100) {
pb$tick()
Sys.sleep(1 / 10)
print(i)
}
pb <- progress_bar$new(
format = "[:bar] :percent eta: :eta",
total = 100, clear = FALSE, width= 60)
for (i in 1:100) {
pb$tick()
Sys.sleep(1 / 10)
print(i*1000)
}
pb <- progress_bar$new(
format = "[:bar] :percent eta: :eta",
total = 100, clear = FALSE, width= 60)
for (i in 1:100) {
pb$tick()
Sys.sleep(1 / 10)
print(i*1000000)
}
i=1
pb$tick()
Sys.sleep(1 / 10)
print(i*1000000)
print(pb$tick())
proc.time()
ptm <- proc.time()
proc.time() - ptm
install.packages("rtweet",dependencies=TRUE)
library(rtweet)
install.packages("rtweet")
library(rtweet)
install.packages("openssl")
install.packages("rtweet",dependencies = TRUE)
install.packages("leaflet", dependecies=TRUE)
install.packages("crosstalk")
install.packages("png")
install.packages("leaflet")
library(leaflet)
basedirectory <- "/Users/alecnelson/Documents/Clemson_Files/MastersThesis/DataAnalysis"
inputdata_path <- "D:/DataAnalysis/TestData"
countryshape_path <- "D:/DataAnalysis/App_Boundary_SHP"
#outputdata_path <- "D:/DataAnalysis/TestResults5"
#monthlydata_path<-"D:/DataAnalysis/MonthlyData3"
sampledata_path<-"D:/DataAnalysis/TestSample"
SampledCSV_path<-"D:/DataAnalysis/SampledClimateData"
EnvirData_path<-"D:/DataAnalysis/EnvironmentData"
CombinIter_NoSeas_path<-"/Users/alecnelson/Documents/Clemson_Files/MastersThesis/DataAnalysis/MultiVarLimit_Iter_NO_SAdj"
CombinIter_SeasAdj_path<-"/Users/alecnelson/Documents/Clemson_Files/MastersThesis/DataAnalysis/MultiVarLimit_Iter_SeasonAdj"
setwd(inputdata_path)
list.of.packages <- c("raster","pracma", "reshape","car","compute.es","effects","rgdal","fields",
"chron", "ff","downloader","magrittr","maptools","GSIF","rgeos","ggplot2",
"multcomp","pastecs","data.table","MuMIn", "ncdf4","sp","dismo","stringr",
"data.table","RCurl","rio","RNetCDF","parallel","qicharts","qcc","zoo","dplyr","purrr","plyr",
"geoR","geoRglm","MSQC","coda","MASS","relaimpo","arcgisbinding","lme4","glmm","nlme","arm","rms")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){install.packages(new.packages)}
#Load all packages
lapply(list.of.packages, require, character.only = TRUE)
setwd(inputdata_path)
raster_file_list <- list.files(pattern = ".nc" , all.files = FALSE , full.names = FALSE )
countryshape<-rgdal::readOGR( countryshape_path, "AppalachianLvl2_GCS84" )
sample_points<-rgdal::readOGR("D:/DataAnalysis", "SamplePoints1")
plot(pch~col)
pch<-seq(1:25)
plot(pch~col)
plot(pch)
plot(NA, xlim=c(1,25), ylim=c(0,1))
points(1:4, runif(4), type="b", pch=19)
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,1))
points(1:4, runif(4), type="b", pch=19)
points(1:25, runif(4), type="b", pch=19)
points(1:20, runif(4), type="b", pch=19)
points(1:20, runif(20), type="b", pch=19)
points(1:20, 1, type="b", pch=19)
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,1))
points(1, type="b", pch=19)
plot(NA, xlim=c(1,25), ylim=c(0,2))
points(1, type="b", pch=19)
points(1, type="b", pch=1)
points(1, type="b", pch=2)
points(1, type="b", pch=1)
points(1, type="b", pch=1, col=1)
points(1, pch=1, col=1)
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
points(1, pch=1, col=1)
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(1, pch=i, col=i)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(1:25, pch=i, col=i)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(1,i, pch=i, col=i)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(i,1, pch=i, col=i)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2))
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2))
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2)+0.2)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2)+1)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2)+1)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(3,3,2,2)+1)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(2,2,1,1)+1)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(2,2,1,1)+2.5)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=i)
}
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(1,25), ylim=c(0,2),xlab="pch, col", ylab="",yaxt="n")
for(i in 1:25){
points(i,1, pch=i, col=2)
}
library(ggplot2)
install.packages("ggplot2")
install.packages("ggplot2")
library(ggplot2)
install.packages("ggplot2")
install.packages("scales")
install.packages("scales")
install.packages("ggplot2")
install.packages("rlang")
install.packages("ggplot2")
install.packages("ggplot2")
x <- seq(-4, 4, length=100)
hx <- dnorm(x)
degf <- c(1, 3, 8, 30)
colors <- c("red", "blue", "darkgreen", "gold", "black")
labels <- c("df=1", "df=3", "df=8", "df=30", "normal")
plot(x, hx, type="l", lty=2, xlab="x value",
ylab="Density", main="Comparison of t Distributions")
for (i in 1:4){
lines(x, dt(x,degf[i]), lwd=2, col=colors[i])
}
legend("topright", inset=.05, title="Distributions",
labels, lwd=2, lty=c(1, 1, 1, 1, 2), col=colors)
x <- seq(-4, 4, length=100)
hx <- dnorm(x)
degf <- c(1, 3, 8, 30)
colors <- c("red", "blue", "darkgreen", "gold", "black")
labels <- c("df=1", "df=3", "df=8", "df=30", "normal")
plot(x, hx, type="l", lty=2, xlab="x value",
ylab="Density", main="Comparison of t Distributions")
for (i in 1:4){
lines(x, dt(x,degf[i]), lwd=2, col=colors[i])
}
dbeta(x, shape1, shape2, ncp = 0, log = FALSE)
dbeta(x, 0.5, 0.5, ncp = 0, log = FALSE)
plot(dbeta(x, 0.5, 0.5, ncp = 0, log = FALSE))
plot(dbeta(x, 0.5, 0.5, ncp = 0, log = FALSE),type="l")
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(0.00,1.00), ylim=c(0.00,2.5),xlab="X", ylab="Density")
lines(dbeta(x, 0.5, 0.5, ncp = 0, log = FALSE))
lines(dbeta(x, 0.5, 0.5, log = FALSE))
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(0.00,1.00), ylim=c(0.00,2.5),xlab="X", ylab="Density")
lines(dbeta(x, 0.5, 0.5, log = FALSE))
par(mar=c(2,2,1,1)+2)
plot(NA, xlim=c(0.00,1.00), ylim=c(0.00,2.5),xlab="X", ylab="Density")
lines(pbeta(x, 0.5, 0.5, log = FALSE))
pbeta(x, 0.5, 0.5, log = FALSE)
p = seq(0,1, length=100)
p = seq(0,1, length=100)
plot(p, dbeta(p, 100, 100), ylab="density", type ="l", col=4)
lines(p, dbeta(p, 10, 10), type ="l", col=3)
lines(p, dbeta(p, 2, 2), col=2)
lines(p, dbeta(p, 1, 1), col=1)
legend(0.7,8, c("Be(100,100)","Be(10,10)","Be(2,2)", "Be(1,1)"),lty=c(1,1,1,1),col=c(4,3,2,1))
p = seq(0,1, length=100)
plot(p, dbeta(p, 0.5, 0.5), ylab="density", type ="l", lty=2)
lines(p, dbeta(p, 0.5, 2.0), type ="l", col="grey")
lines(p, dbeta(p, 2.0, 0.5), lty=4)
lines(p, dbeta(p, 2.0, 2.0), lty=2,col="grey")
par(mar=c(2,2,1,1)+2)
p = seq(0,1, length=100)
plot(p, dbeta(p, 0.5, 0.5), ylab="Density",xlab="X", xlim=c(0.00,1.00), ylim=c(0.00,2.5),type ="l", lty=2)
lines(p, dbeta(p, 0.5, 2.0), type ="l", col="grey")
lines(p, dbeta(p, 2.0, 0.5), lty=4)
lines(p, dbeta(p, 2.0, 2.0), lty=2,col="grey")
library(igraph)
# read.table() is the most common R command for loading data from
# files in which values are in tabular format. The function loads
# the table into a data frame object, which is the basic data type
# for most operations in R. By default, R assumes that the table
# has no header and is delimited by any white space; these
# settings are fine for our purposes here.
#
# One handy aspect of R is that you can read in data from a URL
# directly by referencing the URL in the read.table() function,
# as follows:
advice_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt')
friendship_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Friendship.txt')
reports_to_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-ReportsTo.txt')
View(advice_data_frame)
# For convenience, we can assign column names to our newly
# imported data frames. c() is a common generic R function that
# combines its arguments into a single vector.
colnames(advice_data_frame) <- c('ego', 'alter', 'advice_tie')
head(advice_data_frame)
colnames(friendship_data_frame) <- c('ego', 'alter', 'friendship_tie')
head(friendship_data_frame)
colnames(reports_to_data_frame) <- c('ego', 'alter', 'reports_to_tie')
head(reports_to_data_frame)
View(advice_data_frame)
# Take a look at each data frame using the 'fix()" function. Note that you'll
# need to close each fix window before R will evaluate the next line of code.
fix(advice_data_frame)
# Now that we've verified they are all the same, we can combine them into
# a single data frame.
krack_full_data_frame <- cbind(advice_data_frame,
friendship_data_frame$friendship_tie,
reports_to_data_frame$reports_to_tie)
head(krack_full_data_frame)
names(krack_full_data_frame)[4:5] <- c("friendship_tie",
"reports_to_tie")
head(krack_full_data_frame)
# Another way to build the data frame is to use R's
# data.frame syntax from the start:
krack_full_data_frame <- data.frame(ego = advice_data_frame[,1],
alter = advice_data_frame[,2],
advice_tie = advice_data_frame[,3],
friendship_tie = friendship_data_frame[,3],
reports_to_tie = reports_to_data_frame[,3])
head(krack_full_data_frame)
View(krack_full_data_frame)
View(krack_full_data_frame)
library(igraph)
# read.table() is the most common R command for loading data from
# files in which values are in tabular format. The function loads
# the table into a data frame object, which is the basic data type
# for most operations in R. By default, R assumes that the table
# has no header and is delimited by any white space; these
# settings are fine for our purposes here.
#
# One handy aspect of R is that you can read in data from a URL
# directly by referencing the URL in the read.table() function,
# as follows:
advice_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt')
source("http://sna.stanford.edu/setup.R")
advice_data_frame
#FIZZBUZZ TEST
##################
ptm <- proc.time()
##################
#Alec's For() loop solution
for(i in 1:100){
if((i/3) == as.integer(i/3) & !(i/5) == as.integer(i/5)){
print("Fizz")
}else if (!(i/3) == as.integer(i/3) & (i/5) == as.integer(i/5)){
print("Buzz")
}else if((i/3) == as.integer(i/3) & (i/5) == as.integer(i/5) & (i/15) == as.integer(i/15)){
print("FizzBuzz")
}else{
print(i)
}
}
##################
proc.time() - ptm
##################
##################
ptm <- proc.time()
##################
#Bryan's For() loop solution
for(i in 1:100){
if((i/3) == as.integer(i/3) & (i/5) == as.integer(i/5)){
print("FizzBuzz")
}else if (!(i/3) == as.integer(i/3) & (i/5) == as.integer(i/5)){
print("Buzz")
}else if((i/3) == as.integer(i/3) & !(i/5) == as.integer(i/5)){
print("Fizz")
}else{
print(i)
}
}
##################
proc.time() - ptm
##################
##################
ptm <- proc.time()
##################
#Angela's For() loop solution
for(i in 1:100){
output=""
if((i/3) == as.integer(i/3)){output=paste0(output,"Fizz")}
if((i/5) == as.integer(i/5)){output=paste0(output,"Buzz")}
if(output==""){print(i)}else{print(output)}
}
##################
proc.time() - ptm
##################
##################
ptm <- proc.time()
##################
#Alec's Mutate vector solution
seq<-data.frame(seq(1:100))
fizz<-function(i){ifelse(as.integer(i/3)==i/3,"fizz",i)}
buzz<-function(i){ifelse(as.integer(i/5)==i/5,"buzz",i)}
fizzbuzz<-function(fizz,buzz){ifelse(fizz=="fizz" & buzz=="buzz","fizzbuzz",
ifelse(fizz==buzz,fizz,ifelse(fizz=="fizz",fizz,buzz)))}
seq_fizzbuzz <- mutate(seq, fizz_i = fizz(seq.1.100.),buzz_i=buzz(seq.1.100.),fizzbuzz_i=fizzbuzz(fizz_i,buzz_i))
print(seq_fizzbuzz$fizzbuzz_i)
##################
proc.time() - ptm
##################
library(igraph)
# read.table() is the most common R command for loading data from
# files in which values are in tabular format. The function loads
# the table into a data frame object, which is the basic data type
# for most operations in R. By default, R assumes that the table
# has no header and is delimited by any white space; these
# settings are fine for our purposes here.
#
# One handy aspect of R is that you can read in data from a URL
# directly by referencing the URL in the read.table() function,
# as follows:
advice_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt')
friendship_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Friendship.txt')
reports_to_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-ReportsTo.txt')
source("http://sna.stanford.edu/setup.R")
############################
#basedirectory <- "C:\\Users\\ahn11803\\Documents\\GitHub\\ICON8002_SNA"
basedirectory <- "/Users/alecnelson/Documents/GitHub/ICON8002_SNA"
#inputdata_path <- "C:\\Users\\ahn11803\\Documents\\GitHub\\ICON8002_SNA\\Data"
inputdata_path <- "/Users/alecnelson/Documents/GitHub/ICON8002_SNA/Data"
vertex_datapath<-"vertex_test.csv"
edge_datapath<-"attribute_test1.csv"
setwd(inputdata_path)
list.of.packages <- c("igraph")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){install.packages(new.packages)}
#Load all packages
lapply(list.of.packages, require, character.only = TRUE)
vertex_test<- read.csv(vertex_datapath,header=T)
edge_test<- read.csv(edge_datapath,header=T)
str(vertex_test)
summary(vertex_test)
str(edge_test)
summary(edge_test)
icon.graph <- graph.data.frame(d = edge_test, vertices = vertex_test)
summary(icon.graph)
icon.graph
V(icon.graph)
get.edge.attribute(icon.graph,'beer_gift')
in.degree<-degree(icon.graph,mode="in")
plot(icon.graph,
edge.color=edge_test$beer_gift,
vertex.color=vertex_test$favorite_beer,
edge.arrow.size=.2,
vertex.size=((in.degree)*10),main='ICON Beers Given')
legend(1,
1.25,
legend = c('Beer Types'),
col = vertex_test$favorite_beer,
lty=1,
cex = .7)
dev.off()
get.edge.attribute(icon.graph, 'beer')
plot(icon.graph,edge.color=edge_test$high_five,edge.width=edge_test$high_fives,edge.arrow.size=.2,main='ICON High-Fives (weighted)')
## network metrics
degree(icon.graph)
diameter(icon.graph)
closeness(icon.graph)
reciprocity(icon.graph)
ecount(icon.graph)
vcount(icon.graph)
edge_density(icon.graph)
icon.graph[]
colnames(vertex_test)
# Before we merge these data, we need to make sure 'ego' and 'alter' are the
# same across data sets. We can compare each row using the == syntax.
# The command below should return TRUE for every row if all ego rows
# are the same for advice and friendship:
vertex_test$ego == edge_test$ego
which(vertex_test$ego != edge_test$ego)
View(edge_test)
View(vertex_test)
# Before we merge these data, we need to make sure 'ego' and 'alter' are the
# same across data sets. We can compare each row using the == syntax.
# The command below should return TRUE for every row if all ego rows
# are the same for advice and friendship:
unique(vertex_test$ego) == unique(edge_test$ego)
vertex_test$ego
# Before we merge these data, we need to make sure 'ego' and 'alter' are the
# same across data sets. We can compare each row using the == syntax.
# The command below should return TRUE for every row if all ego rows
# are the same for advice and friendship:
unique(vertex_test$ego) == unique(edge_test$ego)
unique(vertex_test$ego)
unique(edge_test$ego)
# Before we merge these data, we need to make sure 'ego' and 'alter' are the
# same across data sets. We can compare each row using the == syntax.
# The command below should return TRUE for every row if all ego rows
# are the same for advice and friendship:
unique(sort(vertex_test$ego)) == unique(sort(edge_test$ego))
which(unique(sort(vertex_test$ego)) != unique(sort(edge_test$ego)))
edge_test
#Consider subsetting to just certain types of connections or categories
edge_test_subset <- subset(edge_test,
(high_fives > 0 | beer_gift != "none"))
head(edge_test_subset)
edge_test_subset
#Consider subsetting to just certain types of connections or categories
edge_test_subset <- subset(edge_test,
(high_fives > 0 & beer_gift != "none"))
head(edge_test_subset)
edge_test_subset
#
get.edge.attribute(icon.graph,'beer_gift')
icon.graph_symmetrized <- as.undirected(icon.graph, mode='collapse')
icon.graph_symmetrized
icon.graph
icon_beer_none_rm <- delete.edges(icon.graph,
E(icon.graph)[get.edge.attribute(icon.graph,
name = "beer_gift") == "none"])
get.edge.attribute(icon.graph, 'beer')
plot(icon.graph,
edge.color=edge_test$beer_gift,
vertex.color=vertex_test$favorite_beer,
edge.arrow.size=.2,
vertex.size=((in.degree)*10),main='ICON Beers Given')
plot(icon_beer_none_rm,
edge.color=edge_test$beer_gift,
vertex.color=vertex_test$favorite_beer,
edge.arrow.size=.2,
vertex.size=((in.degree)*10),main='ICON Beers Given ("None" removed)')
icon_beer_none_rm
icon.graph
plot(icon_beer_none_rm,
edge.color=edge_test$beer_gift,
vertex.color=vertex_test$favorite_beer,
edge.arrow.size=.2,
vertex.size=((in.degree)*10),main='ICON Beers Given ("None" removed)')
plot(icon.graph,edge.color=edge_test$high_five,edge.width=edge_test$high_fives,edge.arrow.size=.2,main='ICON High-Fives (weighted)')
